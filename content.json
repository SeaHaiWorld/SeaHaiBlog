{"meta":{"title":"SeaHai's Blog","subtitle":"面朝大海，春暖花开","description":"一座孤岛","author":"SeaHai","url":"https://shen-yu.gitee.io","root":"/"},"pages":[{"title":"categories","date":"2020-02-07T15:51:57.858Z","updated":"2020-02-07T15:51:57.858Z","comments":true,"path":"categories/index.html","permalink":"https://shen-yu.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-07T15:52:59.717Z","updated":"2020-02-07T15:52:59.717Z","comments":true,"path":"tags/index.html","permalink":"https://shen-yu.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WebStorm 添加右键菜单","slug":"SoftWare/WebStorm 添加右键菜单","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-10T14:30:55.729Z","comments":true,"path":"2020/ck6gj6oh4000mgkvccdydb8j3/","link":"","permalink":"https://shen-yu.gitee.io/2020/ck6gj6oh4000mgkvccdydb8j3/","excerpt":"打开 Windows 注册器Windows + R 打开运行 =&gt; 输入 regedit =&gt; 确定 添加 WebStorm 右键打开文件找到 HKEY_CLASSES_ROOT/*/shell在 shell 内新建项,命名为 Open With WebStorm在 Open With WebStorm 项上右键新建字符串值 icon在 Open With WebStorm 项内右侧双击默认数值填写右键菜单的名称 Open With WebStorm双击 icon 数值填写 Webstorm路径如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe&quot;在 Open With WebStorm 项下新建 command 项项内默认填写 Webstorm路径 %1如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe %1&quot;此时右键文件时菜单项会有 Open With WebStorm","text":"打开 Windows 注册器Windows + R 打开运行 =&gt; 输入 regedit =&gt; 确定 添加 WebStorm 右键打开文件找到 HKEY_CLASSES_ROOT/*/shell在 shell 内新建项,命名为 Open With WebStorm在 Open With WebStorm 项上右键新建字符串值 icon在 Open With WebStorm 项内右侧双击默认数值填写右键菜单的名称 Open With WebStorm双击 icon 数值填写 Webstorm路径如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe&quot;在 Open With WebStorm 项下新建 command 项项内默认填写 Webstorm路径 %1如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe %1&quot;此时右键文件时菜单项会有 Open With WebStorm 添加 WebStorm 右键打开文件夹找到 HKEY_CLASSES_ROOT/Directory/shell在 shell 内新建项,命名为 Open Floder With WebStorm在 Open Floder With WebStorm 项上右键新建字符串值 icon在 Open Floder With WebStorm 项内右侧双击默认数值填写你右键菜单的名称 Open Floder With WebStorm双击 icon 数值填写Webstorm路径如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe&quot;在 Open Floder With WebStorm 项下新建 command 项项内默认填写 Webstorm路径 %1如：&quot;E:\\WebStorm 2019.3.2\\bin\\webstorm64.exe %1&quot;此时右键文件时菜单项会有 Open Floder With WebStorm","categories":[{"name":"软件配置","slug":"软件配置","permalink":"https://shen-yu.gitee.io/categories/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"https://shen-yu.gitee.io/tags/WebStorm/"},{"name":"注册命令","slug":"注册命令","permalink":"https://shen-yu.gitee.io/tags/%E6%B3%A8%E5%86%8C%E5%91%BD%E4%BB%A4/"}]},{"title":"Ubuntu 配置阿里云源","slug":"Ubuntu/Ubuntu - 配置阿里云源","date":"2020-01-07T16:18:41.000Z","updated":"2020-02-10T08:52:53.395Z","comments":true,"path":"2020/ck6gj6ohd000zgkvcbq16hjul/","link":"","permalink":"https://shen-yu.gitee.io/2020/ck6gj6ohd000zgkvcbq16hjul/","excerpt":"如何换成国内最快的阿里云源第一步：备份源文件 cd /etc/apt/ 然后会显示下面的源文件 sources.list输入命令 sudo cp sources.list sources.list.bak 将 sources.list 备份到 sources.list.bak","text":"如何换成国内最快的阿里云源第一步：备份源文件 cd /etc/apt/ 然后会显示下面的源文件 sources.list输入命令 sudo cp sources.list sources.list.bak 将 sources.list 备份到 sources.list.bak 第二步：替换源文件阿里云源 12345678910111213141516deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # 源码 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted universe multiverse deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse ##测试版源 deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-proposed main restricted universe multiverse # Canonical 合作伙伴和附加 deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu&#x2F; xenial partner deb http:&#x2F;&#x2F;extras.ubuntu.com&#x2F;ubuntu&#x2F; xenial main 替换并保存 sudo vim sources.list 修改文件，替换成阿里云源即可 第三步：更新源和软件 sudo apt-get update 更新源 sudo apt-get upgrade 更新软件","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shen-yu.gitee.io/categories/Ubuntu/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://shen-yu.gitee.io/tags/Vim/"}]},{"title":"用 async/await 来处理异步","slug":"AsyncDeal/AsyncDeal","date":"2019-12-16T12:10:33.000Z","updated":"2020-02-10T14:31:22.796Z","comments":true,"path":"2019/ck6gj6ogi0002gkvcdy6n9a5g/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogi0002gkvcdy6n9a5g/","excerpt":"前言最近在通过 jest-puppeteer E2E 测试用例，使用 async/ await 来实现异步操作，以实现模拟用户操作。 async/await 现在已经被标准化，是时候学习一下了。 async的用法作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为 async就是异步的意思，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。写一个 async 函数 12345async function timeout() &#123; return &#39;hello world&#39;&#125;timeout();console.log(&#39;虽然在后面，但是我先执行&#39;);","text":"前言最近在通过 jest-puppeteer E2E 测试用例，使用 async/ await 来实现异步操作，以实现模拟用户操作。 async/await 现在已经被标准化，是时候学习一下了。 async的用法作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为 async就是异步的意思，异步函数也就意味着该函数的执行不会阻塞后面代码的执行。写一个 async 函数 12345async function timeout() &#123; return &#39;hello world&#39;&#125;timeout();console.log(&#39;虽然在后面，但是我先执行&#39;); 打开浏览器控制台，我们可以看到 Promise 对象async 函数返回的是一个 promise 对象，如果要获取到 promise 返回值，我们应该用 then 方法 1234567async function timeout() &#123; return &#39;hello world&#39;&#125;timeout().then(result &#x3D;&gt; &#123;console.log(result);&#125;)console.log(&#39;虽然在后面，但是我先执行&#39;); 控制台如下： 我们获取到了 hello world , 同时 timeout 的执行也没有阻塞后面代码的执行，和我们刚才说的一致。 抛出错误如果函数内部抛出错误， promise 对象有一个 catch 方法进行捕获错误。 123timeout(false).catch(err &#x3D;&gt; &#123; console.log(err)&#125;) await 的用法await是 等待的意思，那么它等待什么呢，它后面跟着什么呢？其实它后面可以放任何表达式，不过我们更多的是放一个返回 promise 对象的表达式。注意 await 关键字只能放到 async 函数里面 现在写一个函数，让它返回 promise 对象，该函数的作用是2s 之后让数值乘以2 12345678&#x2F;&#x2F; 2s 之后返回双倍的值 function doubleAfter2seconds(num) &#123; return new Promise((resolve, reject) &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; &#123; resolve(2 * num) &#125;, 2000); &#125; ) &#125; 现在再写一个 async 函数，从而可以使用 await 关键字， await 后面放置的就是返回 promise 对象的一个表达式，所以它后面可以写上 doubleAfter2seconds 函数的调用 12345async function testResult() &#123; let result &#x3D; await doubleAfter2seconds(30); console.log(result);&#125;testResult(); 打开控制台，2s 之后，可以看到输出了60。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://shen-yu.gitee.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shen-yu.gitee.io/tags/nodejs/"},{"name":"异步","slug":"异步","permalink":"https://shen-yu.gitee.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"JS中几种常见的遍历","slug":"JavaScript/JavaScriptErgodic","date":"2019-11-25T16:00:00.000Z","updated":"2020-02-10T08:55:29.945Z","comments":true,"path":"2019/ck6gj6ogt0007gkvcdwv6dy81/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogt0007gkvcdwv6dy81/","excerpt":"forEach按照数组或对象中的顺序对当前的元素做一些什么，具体做什么，随便 1234567arr[ ].forEach((item, index, array) &#x3D;&gt; &#123; &#x2F;&#x2F; foreach不支持在循环时添加删除操作 &#x2F;&#x2F; 随便做什么 &#x2F;&#x2F; item：当前项，index：当前项的索引， array：原始数组 &#x2F;&#x2F; 匿名函数中的this 都是指向Window &#x2F;&#x2F; 可以没有返回 &#125;) 1234var ary &#x3D; [1,2,3,4,5];var res &#x3D; ary.forEach((item, index, arr) &#x3D;&gt; &#123; arr[index] &#x3D; item * 10;&#125;) console.log(res) –&gt; undefined console.log(ary) –&gt; Array (5) [10, 20, 30, 40, 50]","text":"forEach按照数组或对象中的顺序对当前的元素做一些什么，具体做什么，随便 1234567arr[ ].forEach((item, index, array) &#x3D;&gt; &#123; &#x2F;&#x2F; foreach不支持在循环时添加删除操作 &#x2F;&#x2F; 随便做什么 &#x2F;&#x2F; item：当前项，index：当前项的索引， array：原始数组 &#x2F;&#x2F; 匿名函数中的this 都是指向Window &#x2F;&#x2F; 可以没有返回 &#125;) 1234var ary &#x3D; [1,2,3,4,5];var res &#x3D; ary.forEach((item, index, arr) &#x3D;&gt; &#123; arr[index] &#x3D; item * 10;&#125;) console.log(res) –&gt; undefined console.log(ary) –&gt; Array (5) [10, 20, 30, 40, 50] filter即过滤器。 例如将数组中大于10的元素放到一个新的数组中，即将数组中的每一项和10做比较，大于10的项放到一个新的数组中。 12345var temp &#x3D; [0, 5, 10, 20, 30].filter((item, index) &#x3D;&gt; &#123; console.log(item); &#x2F;&#x2F; 数组中的每一项 console.log(index); &#x2F;&#x2F; 每一项的索引 return item &gt; 10 &#x2F;&#x2F; 返回大于10的项&#125;) console.log(temp) –&gt; Array (2) [20, 30] map即克隆。 将原始数组中每一项克隆，放到一个新的数组中，结束时，得到一个新的数组，原始数组不变，新数组中的顺序和原始数组中一样 123456arr[ ].map((item, index, array) &#x3D;&gt; &#123; &#x2F;&#x2F; 针对每一项做点什么 &#x2F;&#x2F; item：当前项，index：当前项的索引， array：原始数组 &#x2F;&#x2F; 可以返回一个对象，用于数组元素转对象 return XXX &#x2F;&#x2F; 返回操作后的新项&#125;) 1234var arr2 &#x3D; [1,2,3,4,5]var res2 &#x3D; arr2.map((item, index, array) &#x3D;&gt; &#123; return item * 100&#125;) console.log(res2) –&gt; Array (5) [100, 200, 300, 400, 500] // 原数组拷贝了一份，并进行了修改 console.log(arr2) –&gt; Array (5) [1, 2, 3, 4, 5] // 原数组并未发生变化 123456&#x2F;&#x2F; 数组元素转对象var arr3 &#x3D; [1,2,3,4,5]var obj &#x3D; arr3.map((item) &#x3D;&gt; (&#123; key: item, value: item,&#125;)); console.log(obj) –&gt; Array (5) [{key: 1}, {key: 2}, {key: 3}, {key: 4}, {key: 5}] Object.keys()返回对象中每一项的key的数组 12var obj &#x3D; &#123;&#39;0&#39;:&#39;a&#39;,&#39;1&#39;:&#123;&#39;key&#39;:&#39;1&#39;&#125;,&#39;2&#39;:10,&#39;3&#39;:&#39;xxx&#39;&#125; var keysArr &#x3D; Object.keys(obj); console.log(keysArr); –&gt; Array (4) [‘0’, ‘1’, ‘2’, ‘3’] 结合forEach消除空格 12345removeBlankSpace &#x3D; obj &#x3D;&gt; Object.keys(values) .forEach((key) &#x3D;&gt; &#123; values[key] &#x3D; values[key].trim() &#125;) 结合map获取对象的值 1234getValue &#x3D; obj &#x3D;&gt; Object.keys(obj) .map(key &#x3D;&gt; obj[key]) .join(&#39;,&#39;) reduce累加器。 从数组中第一项开始，每检查一项，就和前面的总和加在一起，加到最后返回总和 12345678var temp &#x3D; [1, 2, 3, 4 ,5].reduce((accumulator, current, index, array) &#x3D;&gt; &#123; console.log(accumulator) &#x2F;&#x2F; 累加器 console.log(currentValue) &#x2F;&#x2F; 当前值 console.log(currentIndex) &#x2F;&#x2F; 当前项的索引 console.log(array) &#x2F;&#x2F; 原始数组 return accumulator + currentValue; &#x2F;&#x2F; 返回所有项的总和&#125;); console.log(temp) –&gt; Number 15 SetES6 中新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成 Set 数据结构。可通过 add() 方法向 Set 结构加入成员， Set 结构不会添加重复的值，通过 Array.from 方法将 Set 结构转为数组。 12345const array &#x3D; [1, 1, 2, 2, 3];function removeDedupe(array) &#123; const set &#x3D; new Set(array) return Array.from(set);&#125; console.log(set) –&gt; Set (3) [1, 2, 3] console.log(array) –&gt; Array (3) [1, 2, 3] Set数据结构类似于数组，但成员的值都是唯一的，没有重复的值。 12345let set &#x3D; new Set();set.add(&#123;&#125;);set.size &#x2F;&#x2F; 1set.add(&#123;&#125;);set.size &#x2F;&#x2F; 2 Set数据结构中，两个对象总视为不相等的（即使为空） Set 结构的实例操作方法 Set.prototype.add(value)：添加某个值，返回 Set 结构本身。 Set.prototype.delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 Set.prototype.has(value)：返回一个布尔值，表示该值是否为Set的成员。 Set.prototype.clear()：清除所有成员，没有返回值。 Set 结构的实例遍历方法 Set.prototype.keys()：返回键名的遍历器 Set.prototype.values()：返回键值的遍历器 Set.prototype.entries()：返回键值对的遍历器 Set.prototype.forEach()：使用回调函数遍历每个成员","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://shen-yu.gitee.io/categories/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://shen-yu.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://shen-yu.gitee.io/tags/JavaScript/"},{"name":"函数遍历","slug":"函数遍历","permalink":"https://shen-yu.gitee.io/tags/%E5%87%BD%E6%95%B0%E9%81%8D%E5%8E%86/"}]},{"title":"记录 Taro 的几个 Demo","slug":"React/TaroDemo","date":"2019-11-04T16:25:13.000Z","updated":"2020-02-07T16:26:59.983Z","comments":true,"path":"2019/ck6gj6ogz000ggkvc3emv5fcj/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogz000ggkvc3emv5fcj/","excerpt":"","text":"Taro 官方文档 Taro UI 整合 taro-dvajs的仿知乎示例 基于 Taro 的小程序图标库 基于 Taro 的 canvas 绘图组件，通过配置的方式生成分享图片 taro框架的缺陷以及注意事项 qq开发者文档 基于 Tarojs 微信小程序 Demo","categories":[{"name":"Taro","slug":"Taro","permalink":"https://shen-yu.gitee.io/categories/Taro/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://shen-yu.gitee.io/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Demo","slug":"Demo","permalink":"https://shen-yu.gitee.io/tags/Demo/"}]},{"title":"Thinkjs - 解决跨域问题","slug":"Thinkjs/Thinkjs - 解决跨域","date":"2019-10-04T16:00:00.000Z","updated":"2020-02-10T14:32:07.607Z","comments":true,"path":"2019/ck6gj6oh9000ugkvc4abz4ksz/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oh9000ugkvc4abz4ksz/","excerpt":"场景学习 Thinkjs 3.0 ，但是前后台分离，产生了跨域问题 问题描述","text":"场景学习 Thinkjs 3.0 ，但是前后台分离，产生了跨域问题 问题描述 koa2 的跨域问题可以通过引入koa-cors2来解决 解决方案安装 kcors1npm install kcors –save 引入kcors在中间件 middleware.js 中引入 kcors 1const kcors &#x3D; require(&#39;kcors&#39;); &#x2F;&#x2F; 引入kcors 12345678module.exports &#x3D; [... &#123; handle: kcors, &#x2F;&#x2F; 处理跨域 options: &#123;&#125; &#125;,...&#125; 参考文档kcors-npm 包管理: https://www.npmjs.com/package/koa-cors Thinkjs 官方文档： https://thinkjs.org/zh-cn/doc/3.0/index.html","categories":[{"name":"后端","slug":"后端","permalink":"https://shen-yu.gitee.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Thinkjs","slug":"Thinkjs","permalink":"https://shen-yu.gitee.io/tags/Thinkjs/"},{"name":"Kors","slug":"Kors","permalink":"https://shen-yu.gitee.io/tags/Kors/"}]},{"title":"Thinkjs - 数据库配置","slug":"Thinkjs/Thinkjs - 数据库配置","date":"2019-09-21T16:00:00.000Z","updated":"2020-02-10T09:15:12.789Z","comments":true,"path":"2019/ck6gj6oha000wgkvc9lhn1uvl/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oha000wgkvc9lhn1uvl/","excerpt":"配置 database.js 文件12345678910111213&#x2F;&#x2F; database.jsmodule.exports &#x3D; &#123; handle: mysql, database: &#39;think&#39;, &#x2F;&#x2F; database_name prefix: &#39;think_&#39;, &#x2F;&#x2F; database_table 前缀 encoding: &#39;utf8mb4&#39;, host: &#39;127.0.0.1&#39;, &#x2F;&#x2F; Your MySQL host port: &#39;3306&#39;, &#x2F;&#x2F; Your MySQL port user: &#39;user&#39;, &#x2F;&#x2F; Your MySQL userName password: &#39;password&#39;, &#x2F;&#x2F; Your MySQL password dateStrings: true&#125;;","text":"配置 database.js 文件12345678910111213&#x2F;&#x2F; database.jsmodule.exports &#x3D; &#123; handle: mysql, database: &#39;think&#39;, &#x2F;&#x2F; database_name prefix: &#39;think_&#39;, &#x2F;&#x2F; database_table 前缀 encoding: &#39;utf8mb4&#39;, host: &#39;127.0.0.1&#39;, &#x2F;&#x2F; Your MySQL host port: &#39;3306&#39;, &#x2F;&#x2F; Your MySQL port user: &#39;user&#39;, &#x2F;&#x2F; Your MySQL userName password: &#39;password&#39;, &#x2F;&#x2F; Your MySQL password dateStrings: true&#125;; 配置 adapter.js 文件12345678910111213&#x2F;&#x2F; adapter.jsconst database &#x3D; require(&#39;.&#x2F;database.js&#39;); &#x2F;&#x2F; 引用database.js...exports.model &#x3D; &#123; type: &#39;mysql&#39;, common: &#123; logConnect: isDev, logSql: isDev, logger: msg &#x3D;&gt; think.logger.info(msg) &#125;, mysql: database &#125;; 或直接在 adapter.js 内配置12345678910111213141516171819202122&#x2F;&#x2F; adapter.jsconst mysql &#x3D; require(&#39;think-model-mysql&#39;);...exports.model &#x3D; &#123; type: &#39;mysql&#39;, common: &#123; logConnect: isDev, logSql: isDev, logger: msg &#x3D;&gt; think.logger.info(msg) &#125;, mysql: &#123; handle: mysql, database: &#39;think&#39;, &#x2F;&#x2F; database_name prefix: &#39;think_&#39;, &#x2F;&#x2F; database_table 前缀 encoding: &#39;utf8mb4&#39;, host: &#39;127.0.0.1&#39;, &#x2F;&#x2F; Your MySQL host port: &#39;3306&#39;, &#x2F;&#x2F; Your MySQL port user: &#39;user&#39;, &#x2F;&#x2F; Your MySQL userName password: &#39;password&#39;, &#x2F;&#x2F; Your MySQL password dateStrings: true &#125;&#125;;","categories":[{"name":"后端","slug":"后端","permalink":"https://shen-yu.gitee.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Thinkjs","slug":"Thinkjs","permalink":"https://shen-yu.gitee.io/tags/Thinkjs/"},{"name":"数据库操作","slug":"数据库操作","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"name":"MySQL","slug":"MySQL","permalink":"https://shen-yu.gitee.io/tags/MySQL/"}]},{"title":"Navicat 中 csv 文件导入 MySQL","slug":"SQL/SQLImportByNavicate","date":"2019-09-19T16:00:00.000Z","updated":"2020-02-10T08:57:18.030Z","comments":true,"path":"2019/ck6gj6oh8000sgkvc8uda6rzp/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oh8000sgkvc8uda6rzp/","excerpt":"","text":"Navicat 中 csv 、json 文件导入 MySQL 主要问题: 解决乱码、导入 sql、csv、json 文件 借助工具： Navicat、Notopad、MySQL","categories":[{"name":"数据库操作","slug":"数据库操作","permalink":"https://shen-yu.gitee.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"Navicat","slug":"Navicat","permalink":"https://shen-yu.gitee.io/tags/Navicat/"},{"name":"Mysql","slug":"Mysql","permalink":"https://shen-yu.gitee.io/tags/Mysql/"}]},{"title":"Thinkjs - CRUD 操作","slug":"Thinkjs/Thinkjs - CRUD 操作","date":"2019-09-15T16:00:00.000Z","updated":"2020-02-10T08:59:01.067Z","comments":true,"path":"2019/ck6gj6oh5000ogkvc14mkd8h0/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oh5000ogkvc14mkd8h0/","excerpt":"增添加单条数据使用 add 方法可以添加一条数据，返回值为插入数据的 id。如： 1234async addAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const id &#x3D; await model.add(&#123;name: &#39;xxx&#39;, id: &#39;yyy&#39;&#125;);&#125; 添加多条数据使用 addMany 方法可以添加多条数据，如： 12345678async addAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const insertId &#x3D; await model.addMany( [ &#123;name: &#39;xxx1&#39;, pwd: &#39;yyy1&#39;&#125;, &#123;name: &#39;xxx2&#39;, pwd: &#39;yyy2&#39;&#125; ] )&#125; 注：addMany添加多条数据时应该插入一个数组","text":"增添加单条数据使用 add 方法可以添加一条数据，返回值为插入数据的 id。如： 1234async addAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const id &#x3D; await model.add(&#123;name: &#39;xxx&#39;, id: &#39;yyy&#39;&#125;);&#125; 添加多条数据使用 addMany 方法可以添加多条数据，如： 12345678async addAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const insertId &#x3D; await model.addMany( [ &#123;name: &#39;xxx1&#39;, pwd: &#39;yyy1&#39;&#125;, &#123;name: &#39;xxx2&#39;, pwd: &#39;yyy2&#39;&#125; ] )&#125; 注：addMany添加多条数据时应该插入一个数组 删使用 delete 方法来删除数据。如： 1234async deleteAction()&#123; let model &#x3D; this.model(&#39;user&#39;); let affectedRows &#x3D; await model.where(&#123;id: [&#39;&gt;&#39;, 100]&#125;).delete();&#125; 改使用 update 方法来更新数据。如： 123456module.exports &#x3D; class extends think.Controller &#123; async updateAction()&#123; let model &#x3D; this.model(&#39;user&#39;); let affectedRows &#x3D; await model.where(&#123;name: &#39;thinkjs&#39;&#125;).update(&#123;email: &#39;admin@thinkjs.org&#39;&#125;); &#125;&#125; 查查询单条数据使用 find 方法查询单条数据，返回值为对象。如： 12345async listAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const data &#x3D; await model.where(&#123;name: &#39;thinkjs&#39;&#125;).find(); &#x2F;&#x2F; data will returns &#123;name: &#39;thinkjs&#39;, email: &#39;admin@thinkjs.org&#39;, ...&#125;&#125; 注：如果数据表没有对应的数据，那么返回值为空对象 {}，可以通过 think.isEmpty 方法来判断返回值是否为空。 查询指定字段使用 getField 方法查询指定字段的值。如： 1234567891011121314151617181920212223242526272829303132333435获取单个字段的所有列表 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id&#39;); &#x2F;&#x2F; data &#x3D; [1, 2, 3, 4, 5] &#125;指定个数获取单个字段的列表 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id&#39;, 3); &#x2F;&#x2F; data &#x3D; [1, 2, 3] &#125;获取单个字段的一个值 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id&#39;, true); &#x2F;&#x2F; data &#x3D; 1 &#125;获取多个字段的所有列表 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id,d_name&#39;); &#x2F;&#x2F; data &#x3D; &#123;c_id: [1, 2, 3, 4, 5], d_name: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]&#125; &#125;获取指定个数的多个字段的所有列表 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id,d_name&#39;, 3); &#x2F;&#x2F; data &#x3D; &#123;c_id: [1, 2, 3], d_name: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]&#125; &#125;获取多个字段的单一值 async listAction()&#123; const data &#x3D; await this.model(&#39;user&#39;).getField(&#39;c_id,d_name&#39;, true); &#x2F;&#x2F; data &#x3D; &#123;c_id: 1, d_name: &#39;a&#39;&#125; &#125; 查询多条数据使用 select 方法查询多条数据，返回值为数组。如： 1234567async listAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const data &#x3D; await model.limit(2).select(); &#x2F;&#x2F; data will returns [&#123;name: &#39;test&#39;, email: &#39;test@thinkjs.org&#39;, ...&#125; &#123;name: &#39;thinkjs&#39;, email: &#39;admin@thinkjs.org&#39;, ...&#125;]&#125; 查询数据条数使用 count 方法来方便查询总条数。如： 1234async listAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const data &#x3D; await model.count();&#125; 分页查询数据使用 countSelect 方法实现分页查询。如： 1234async listAction()&#123; const model &#x3D; this.model(&#39;user&#39;); const data &#x3D; await model.page(currentPage, pageSize).countSelect();&#125; 返回如下: 1234567&#123; data: array &#x2F;&#x2F;当前页下的数据列表 count: number, &#x2F;&#x2F;总条数 totalPages: number, &#x2F;&#x2F;总页数 pageSize: number, &#x2F;&#x2F;每页显示的条数 currentPage: number, &#x2F;&#x2F;当前页&#125;","categories":[{"name":"后端","slug":"后端","permalink":"https://shen-yu.gitee.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Thinkjs","slug":"Thinkjs","permalink":"https://shen-yu.gitee.io/tags/Thinkjs/"},{"name":"数据库操作","slug":"数据库操作","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"name":"MySQL","slug":"MySQL","permalink":"https://shen-yu.gitee.io/tags/MySQL/"}]},{"title":"React - 请求数据","slug":"React/Request","date":"2019-08-14T16:00:00.000Z","updated":"2020-02-10T14:50:21.529Z","comments":true,"path":"2019/ck6gj6ogw000bgkvchnd39jsf/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogw000bgkvchnd39jsf/","excerpt":"axios安装axios，这里使用的cnpm 1npm isntall axios --save 简单使用 123456789101112import axios from &quot;axios&quot;;componentDidMount() &#123; this.listRender();&#125;listRender &#x3D; e &#x3D;&gt; &#123; const _this &#x3D; this; axios.get(&quot;url&quot;).then(res &#x3D;&gt; &#123; _this.setState(&#123; data: res.data &#125;); &#125;);&#125;","text":"axios安装axios，这里使用的cnpm 1npm isntall axios --save 简单使用 123456789101112import axios from &quot;axios&quot;;componentDidMount() &#123; this.listRender();&#125;listRender &#x3D; e &#x3D;&gt; &#123; const _this &#x3D; this; axios.get(&quot;url&quot;).then(res &#x3D;&gt; &#123; _this.setState(&#123; data: res.data &#125;); &#125;);&#125; ajax安装 jquery ，引用 $ 1npm isntall jquery --save 简单使用 1234567891011121314151617import $ from &#39;jquery&#39;;componentDidMount() &#123; this.listRender();&#125;listRender &#x3D; e &#x3D;&gt; &#123; $.ajax(&#123; type: &quot;POST&quot;, url: &quot;url&quot;, dataType: &quot;json&quot;, &#125;).then(res &#x3D;&gt; &#123; this.setState(&#123; list: res.data.data, &#125;); &#125;);&#125; fetch12345678910111213componentDidMount() &#123; this.listRender();&#125;listRender &#x3D; e &#x3D;&gt; &#123; fetch(&quot;url&quot;, &#123; method: &quot;GET&quot; &#125;) .then(res &#x3D;&gt; res.json()) .then(data &#x3D;&gt; &#123; this.setState(&#123; data: data &#125;); &#125;);&#125;","categories":[{"name":"React","slug":"React","permalink":"https://shen-yu.gitee.io/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shen-yu.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://shen-yu.gitee.io/tags/ES6/"},{"name":"数据处理","slug":"数据处理","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"Vim - 常用命令记录","slug":"Ubuntu/Vim - 常用命令记录","date":"2019-08-13T16:00:00.000Z","updated":"2020-02-10T14:34:09.785Z","comments":true,"path":"2019/ck6gj6ohg0014gkvcf56u8beb/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ohg0014gkvcf56u8beb/","excerpt":"Vim常用命令记录文件的打开与保存 vim filename //打开名为filename的文件 :w //保存修改至源文件 :wq //保存修改并退出 :q! //不保存修改，直接退出 :w filename //保存修改(选中的部分)至filename(filename为新文件)","text":"Vim常用命令记录文件的打开与保存 vim filename //打开名为filename的文件 :w //保存修改至源文件 :wq //保存修改并退出 :q! //不保存修改，直接退出 :w filename //保存修改(选中的部分)至filename(filename为新文件) 文件编辑 i //insert即插入模式，从光标所在位置开始插入，即插入的内容位于原光标所在位置字符之前 I //从光标所在行的行首开始插入 a //append即附加模式，从光标所在位置之后附加，即新增内容位于原光标所在位置字符之后 A //从光标所在行的行末开始附加 o //在光标所在行的下一行加入新一行 O //在光标所在行的上一行加入新一行 R //进入替换模式，屏幕下方会出现Replace提示，此时的输入会直接替换光标所在位置的字符，与Windows下的 0 作用类似，同样通过ESC键返回 删除操作 x //删除光标所在处的字符(其大写形式X为将光标之前的字符删除，相当于Backspace) dd //删除光标所在行的操作(常用) 撤销操作 u //撤销上一次操作 U //撤销对光标所在行的所有操作 Ctrl+r //重做上一操作","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shen-yu.gitee.io/categories/Ubuntu/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://shen-yu.gitee.io/tags/Vim/"},{"name":"命令行","slug":"命令行","permalink":"https://shen-yu.gitee.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"}]},{"title":"React - 双向绑定","slug":"React/Binding","date":"2019-08-11T16:00:00.000Z","updated":"2020-02-07T16:14:20.478Z","comments":true,"path":"2019/ck6gj6ogr0006gkvcgvqx7rfm/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogr0006gkvcgvqx7rfm/","excerpt":"","text":"ref 的 DOM 操作React.js 当中提供了 ref 属性来帮助我们获取已经挂载的元素的 DOM 节点，你可以给某个 JSX 元素加上 ref属性： 123456789101112131415161718192021222324&#x2F;&#x2F;输入框自动聚焦,按钮绑定搜索class AutoFocusInput extends Component &#123; componentDidMount () &#123; this.input.focus() &#125; handleClick &#x3D; e &#x3D;&gt; &#123; const _post &#x3D; &#123; search: this.input.value &#125; render () &#123; return ( &lt;input ref&#x3D;&#123;(input) &#x3D;&gt; this.input &#x3D; input&#125; &#x2F;&gt; &lt;button onClick&#x3D;&#123;this.handleClick.bind(this)&#125; &#x2F;&gt; ) &#125;&#125;ReactDOM.render( &lt;AutoFocusInput &#x2F;&gt;, document.getElementById(&#39;root&#39;)) 可以看到我们给 input 元素加了一个 ref 属性，这个属性值是一个函数。当 input 元素在页面上挂载完成以后，React.js 就会调用这个函数，并且把这个挂载以后的 DOM 节点传给这个函数。在函数中我们把这个 DOM 元素设置为组件实例的一个属性，这样以后我们就可以通过 this.input 获取到这个 DOM 元素。 然后我们就可以在 componentDidMount 中使用这个 DOM 元素，并且调用 this.input.focus() 的 DOM API。整体就达到了页面加载完成就自动 focus 到输入框的功能（大家可以注意到我们用上了 componentDidMount 这个组件生命周期）。 我们可以给任意代表 HTML 元素标签加上 ref 从而获取到它 DOM 元素然后调用 DOM API。但是记住一个原则：能不用 ref 就不用。特别是要避免用 ref 来做 React.js 本来就可以帮助你做到的页面自动更新的操作和事件监听。多余的 DOM 操作其实是代码里面的“噪音”，不利于我们理解和维护。 顺带一提的是，其实可以给组件标签也加上 ref ，例如： 1&lt;Clock ref&#x3D;&#123;(clock) &#x3D;&gt; this.clock &#x3D; clock&#125; &#x2F;&gt; 这样你获取到的是这个 Clock 组件在 React.js 内部初始化的实例。但这并不是什么常用的做法，而且也并不建议这么做，所以这里就简单提及，有兴趣的朋友可以自己学习探索。","categories":[{"name":"React","slug":"React","permalink":"https://shen-yu.gitee.io/categories/React/"}],"tags":[{"name":"DOM 操作","slug":"DOM-操作","permalink":"https://shen-yu.gitee.io/tags/DOM-%E6%93%8D%E4%BD%9C/"},{"name":"前端","slug":"前端","permalink":"https://shen-yu.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://shen-yu.gitee.io/tags/ES6/"}]},{"title":"React - 父子传值","slug":"React/DataTransmit","date":"2019-08-10T16:00:00.000Z","updated":"2020-02-10T09:02:16.175Z","comments":true,"path":"2019/ck6gj6ogx000cgkvc8zhj2f0s/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogx000cgkvc8zhj2f0s/","excerpt":"在React项目里，父子组件传值是比较常见的，今天学习了一下React的父子组件传值。 父组件向子组件传值：父通过初始state，子组件通过this.props进行接收就可以了； 子组件向父组件传值：需要绑定一个事件，然后事件是父组件传递过来的this.props.event来进行值的更替。 父向子传值： 父组件 Comment.js ，子组件 ComentList.js 父通过初始 state ，子组件通过 props 进行接收就可以了；","text":"在React项目里，父子组件传值是比较常见的，今天学习了一下React的父子组件传值。 父组件向子组件传值：父通过初始state，子组件通过this.props进行接收就可以了； 子组件向父组件传值：需要绑定一个事件，然后事件是父组件传递过来的this.props.event来进行值的更替。 父向子传值： 父组件 Comment.js ，子组件 ComentList.js 父通过初始 state ，子组件通过 props 进行接收就可以了； 12345678910111213141516171819202122&#x2F;&#x2F; Comment.js import React from &quot;react&quot;import ComentList from &quot;.&#x2F;ComentList&quot; class Comment extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; arr:[&quot;123&quot;,] &#125; render() &#123; return ( &lt;div&gt; &lt;ComentList arr&#x3D;&#123;this.state.arr&#125;&gt; &lt;&#x2F;ComentList&gt; &lt;&#x2F;div&gt; ) &#125; &#125;&#125;export default Comment; 1234567891011121314151617181920212223242526272829&#x2F;&#x2F; ComentList.js import React from &quot;react&quot; class ComentList extends React.Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;div className&#x3D;&quot;list&quot;&gt; &lt;ul&gt; &#123; this.props.arr.map(item &#x3D;&gt; &#123; &#x2F;&#x2F;这个地方通过 this.props 父组件传过来数据，使用 map循环 return ( &lt;li key&#x3D;&#123;item&#125;&gt; 评论是:&#123;item&#125; &lt;&#x2F;li&gt; ) &#125;) &#125; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt; ) &#125;&#125; export default ComentList; 子向父传值绑定一个事件，然后事件是父组件传递过来的this.props.event来进行值的更替。 1234567891011121314151617181920212223242526272829303132333435363738394041&#x2F;&#x2F; Comment.js import React from &quot;react&quot;import ComentList from &quot;.&#x2F;ComentList&quot; class Comment extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; &#123; parentText: &quot;this is parent text&quot;, arr: [&#123; &quot;userName&quot;: &quot;fangMing&quot;, &quot;text&quot;: &quot;123&quot;, &quot;result&quot;: true &#125;, &#123; &quot;userName&quot;: &quot;zhangSan&quot;, &quot;text&quot;: &quot;345&quot;, &quot;result&quot;: false &#125;, &#123; &quot;userName&quot;: &quot;liSi&quot;, &quot;text&quot;: &quot;567&quot;, &quot;result&quot;: true &#125;, &#123; &quot;userName&quot;: &quot;wangWu&quot;, &quot;text&quot;: &quot;789&quot;, &quot;result&quot;: true &#125;,] &#125; &#125; fn(data) &#123; this.setState(&#123; parentText: data &#x2F;&#x2F;把父组件中的parentText替换为子组件传递的值 &#125;,() &#x3D;&gt;&#123; console.log(this.state.parentText); &#125;); &#125; render() &#123; return ( &lt;div&gt; &#x2F;&#x2F;通过绑定事件进行值的运算，这个地方一定要记得.bind(this)， &lt;ComentList arr&#x3D;&#123;this.state.arr&#125; pfn&#x3D;&#123;this.fn.bind(this)&#125; &#x2F;&gt; &lt;p&gt;text is &#123;this.state.parentText&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; ) &#125;&#125;export default Comment; 12345678910111213141516171819202122232425262728293031&#x2F;&#x2F; ComentList.jsimport React from &quot;react&quot; class ComentList extends React.Component &#123; constructor(props) &#123; super(props); this.state &#x3D; (&#123; childText: &quot;this is child text&quot; &#125;) &#125; clickFun(text) &#123; this.props.pfn(text)&#x2F;&#x2F;这个地方把值传递给了props的事件当中 &#125; render() &#123; return ( &lt;div className&#x3D;&quot;list&quot;&gt; &lt;ul&gt; &#123; this.props.arr.map(item &#x3D;&gt; &#123; return ( &lt;li key&#x3D;&#123;item.userName&#125;&gt;&#123;item.userName&#125; 评论是:&#123;item.text&#125;&lt;&#x2F;li&gt; ) &#125;) &#125; &lt;&#x2F;ul&gt; &lt;button onClick&#x3D;&#123;this.clickFun.bind(this, this.state.childText)&#125;&gt;click me&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; ) &#125;&#125; export default ComentList;","categories":[{"name":"React","slug":"React","permalink":"https://shen-yu.gitee.io/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shen-yu.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://shen-yu.gitee.io/tags/ES6/"},{"name":"数据处理","slug":"数据处理","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"React - 路由跳转","slug":"React/Router","date":"2019-08-09T16:00:00.000Z","updated":"2020-02-10T09:02:51.972Z","comments":true,"path":"2019/ck6gj6oh2000igkvc1kb9g9uy/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oh2000igkvc1kb9g9uy/","excerpt":"前言在一张页面中，我们该如何去实现页面跳转呢 Router提供了页面跳转渲染的方法，React应用会根据链接地址去决定要渲染的内容。链接地址不再是直接跳转，而是去告诉React，我需要怎么样的内容，让React去条件渲染 创建页面首先，我们快速创建一个 React-app 应用。 删去src目录下的所有文件，新建 index 1234567&#x2F;&#x2F; index.js import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;.&#x2F;App&#39;;ReactDOM.render(&lt;App&#x2F;&gt;, document.getElementById(&#39;root&#39;));","text":"前言在一张页面中，我们该如何去实现页面跳转呢 Router提供了页面跳转渲染的方法，React应用会根据链接地址去决定要渲染的内容。链接地址不再是直接跳转，而是去告诉React，我需要怎么样的内容，让React去条件渲染 创建页面首先，我们快速创建一个 React-app 应用。 删去src目录下的所有文件，新建 index 1234567&#x2F;&#x2F; index.js import React from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;import App from &#39;.&#x2F;App&#39;;ReactDOM.render(&lt;App&#x2F;&gt;, document.getElementById(&#39;root&#39;)); 123456789101112131415161718192021222324&#x2F;&#x2F; App.jsimport React from &#39;react&#39;;import &#123;Router&#125; from &#39;react-router-dom&#39;;import Home from &#39;.&#x2F;Home&#39;;import Page1 from &#39;.&#x2F;Page1&#39;;import Page2 from &#39;.&#x2F;Page2&#39;;import Page3 from &#39;.&#x2F;Page3&#39;; class App extends React.Component &#123; render()&#123; return( &lt;Router &gt; &lt;div&gt; &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt; &lt;Route path&#x3D;&quot;&#x2F;Page1&quot; component&#x3D;&#123;Page1&#125; &#x2F;&gt; &lt;Route path&#x3D;&quot;&#x2F;Page2&quot; component&#x3D;&#123;Page2&#125; &#x2F;&gt; &lt;Route path&#x3D;&quot;&#x2F;Page3&quot; component&#x3D;&#123;Page3&#125; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;&#x2F;Router&gt; ) &#125;&#125;export default App; 依次创建页面组件：Home、Page1、Page2、Page3；同时引入Link进行页面跳转 1234567891011121314151617181920212223242526&#x2F;&#x2F; Home.jsimport React from &#39;react&#39;;import &#123; Link &#125; from &#39;react-router-dom&#39;; class Home extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt;This is Home!&lt;&#x2F;div&gt; &lt;div&gt; &lt;Link to&#x3D;&quot;&#x2F;Page1&#x2F;&quot; style&#x3D;&#123;&#123;color:&#39;black&#39;&#125;&#125;&gt; &lt;div&gt;点击跳转到Page1&lt;&#x2F;div&gt; &lt;&#x2F;Link&gt; &lt;Link to&#x3D;&quot;&#x2F;Page2&#x2F;&quot; style&#x3D;&#123;&#123;color:&#39;black&#39;&#125;&#125;&gt; &lt;div&gt;点击跳转到Page2&lt;&#x2F;div&gt; &lt;&#x2F;Link&gt; &lt;Link to&#x3D;&quot;&#x2F;Page3&#x2F;&quot; style&#x3D;&#123;&#123;color:&#39;black&#39;&#125;&#125;&gt; &lt;div&gt;点击跳转到Page3&lt;&#x2F;div&gt; &lt;&#x2F;Link&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt; ); &#125;&#125;export default Home; 123456789101112131415&#x2F;&#x2F;Page1~Page3页面类似，不再赘述 import React from &#39;react&#39;;class Page1 extends React.Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt;This is Page1!&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; ); &#125;&#125;export default Page1;&#x2F;&#x2F; Page1~Page3页面类似，不再赘述 exact 属性可以通过 exact 属性来选择渲染时不默认渲染这个页面 12&lt;Route exact path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;Home&#125; &#x2F;&gt;&#x2F;&#x2F; 此时，当在跳转到 Page1 时，即使包含了 path&#x3D;&quot;&#x2F;&quot; ,默认不会渲染 path&#x3D;&quot;&#x2F;&quot; 的组件 点击”点击跳转到Page1”","categories":[{"name":"React","slug":"React","permalink":"https://shen-yu.gitee.io/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://shen-yu.gitee.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://shen-yu.gitee.io/tags/ES6/"},{"name":"页面交互","slug":"页面交互","permalink":"https://shen-yu.gitee.io/tags/%E9%A1%B5%E9%9D%A2%E4%BA%A4%E4%BA%92/"}]},{"title":"Jest - 单元测试及可视化报告","slug":"JestTest/JestTest","date":"2019-07-12T12:10:33.000Z","updated":"2020-02-10T09:10:09.739Z","comments":true,"path":"2019/ck6gj6ogu0008gkvc45cg7uyo/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogu0008gkvc45cg7uyo/","excerpt":"准备工作 安装 jest cnpm install –save-dev jest 查看版本 jest -v 确保你的项目已经安装了版本较新的 jest 测试框架(随版本更迭有可能产生无法预知的BUG，如：配置属性名变更) 已完成对 jest 配置文件 jest.config.js 的基本配置 函数测试 首先要做的事情：What needs to be tested?？ 如果你正在编写 Web 应用，那么一个好的起点就是测试应用的每个页面和每个用户交互。但 Web 应用由单元代码组成，如 UI 、函数和组件，分别需要单独进行测试。","text":"准备工作 安装 jest cnpm install –save-dev jest 查看版本 jest -v 确保你的项目已经安装了版本较新的 jest 测试框架(随版本更迭有可能产生无法预知的BUG，如：配置属性名变更) 已完成对 jest 配置文件 jest.config.js 的基本配置 函数测试 首先要做的事情：What needs to be tested?？ 如果你正在编写 Web 应用，那么一个好的起点就是测试应用的每个页面和每个用户交互。但 Web 应用由单元代码组成，如 UI 、函数和组件，分别需要单独进行测试。 函数单元测试两种情况： 你正接手一些函数功能未知的代码 你要实现之前没有的新功能,但不知是否实现 对于这两种情况，你可以通过将测试看作检查给定函数是否产生预期结果来帮助自己。 以下是典型测试流程的样子： 导入要测试的函数 给函数输入 定义期望 检查是否按预期输出 只需这样执行：输入 → 预期输出 → 断言结果 书写测试用例以下是一个完整的测试用例 创建 filename.js 文件，描述测试函数 1234&#x2F;&#x2F; utils.jsexport function fixedZero(val) &#123; return val * 1 &lt; 10 ? &#96;0$&#123;val&#125;&#96; : val;&#125; 创建 filename.test.js 文件,描述断言 123456789101112131415161718192021222324252627282930313233&#x2F;&#x2F; utils.test.jsimport &#123; fixedZero &#125; from &#39;.&#x2F;utils&#39;;...&#x2F;&#x2F; describe(&#39;函数分组测试描述&#39;,() &#x3D;&gt; &#123;&#x2F;&#x2F; test(&#39;单元测试描述&#39;, () &#x3D;&gt; &#123;&#x2F;&#x2F; expect(&quot;函数结果&quot;).toEqual(&quot;期望结果&quot;);&#x2F;&#x2F; &#125;); &#x2F;&#x2F; &#125;)describe(&#39;fixedZero tests&#39;, () &#x3D;&gt; &#123; it(&#39;should not pad large numbers&#39;, () &#x3D;&gt; &#123; expect(fixedZero(10)).toEqual(10); expect(fixedZero(11)).toEqual(11); expect(fixedZero(15)).toEqual(15); expect(fixedZero(20)).toEqual(20); expect(fixedZero(100)).toEqual(100); expect(fixedZero(1000)).toEqual(1000); expect(fixedZero(1000)).toEqual(1000);&#125;); it(&#39;should pad single digit numbers and return them as string&#39;, () &#x3D;&gt; &#123; expect(fixedZero(0)).toEqual(&#39;00&#39;); expect(fixedZero(1)).toEqual(&#39;01&#39;); expect(fixedZero(2)).toEqual(&#39;02&#39;); expect(fixedZero(3)).toEqual(&#39;03&#39;); expect(fixedZero(4)).toEqual(&#39;04&#39;); expect(fixedZero(5)).toEqual(&#39;05&#39;); expect(fixedZero(6)).toEqual(&#39;06&#39;); expect(fixedZero(7)).toEqual(&#39;07&#39;); expect(fixedZero(8)).toEqual(&#39;08&#39;); expect(fixedZero(9)).toEqual(&#39;09&#39;); &#125;);&#125;); 在命令行输入npm test utils.test.js，我们可以看到命令台的返回 实现在浏览器上实现测试结果的可视化显示 当我们对一些比较庞大的项目，要进行成百上千个函数进行单元测试时，测试结果仅仅显示在控制台明显不够看。如何优雅的让测试结果展示出来，并可以详细的观察测试结果的具体问题呢？ 我们会想到将 jest 的测试结果 –&gt; 存储 –&gt; 发请求(简单服务器) –&gt; 发送到浏览器 –&gt; 展示 两种方法 通过 nodejs 实现但是需要配置一个简单的 node 服务器，来实现在浏览器显示。但是方法过于繁琐，不在赘述。 借助于报告工具 jest-html-report (本质与第一个方法没有区别，只是这个工具是打包好的 node 库，可以直接投入使用) 参数配置根据 jest 官方文档在 jest.config.js 中有 testResultsProcessor 属性： Property Description Type Default testResultsProcessor This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it: string undefined 这个属性可以允许结果处理程序使用。这个处理器必须是一个输出函数的 node 模块，这个函数的第一个参数会接收测试结果，且必须在最终返回测试结果。可以用与于接收测试结果，且在最终返回测试结果 首先我们安装它：cnpm install jest-html-report –save-dev 在 jest.config.js 中，具体配置 jest-html-reporter 的属性 用到的属性： Property Description Type Default pageTitle The title of the document string “Test Suite” outputPath The path to where the plugin will output the HTML report string “./test-report.html” includeFailureMsg If this setting is set to true, this will output the detailed failure message for each failed test. boolean false 其他属性参考官方文档：https://github.com/Hargne/jest-html-reporter/wiki/configuration 完成 jest.config.js 中 jest-html-reporter 的配置： 12345678910111213141516171819&#x2F;&#x2F;jest.config.jsmodule.exports&#x3D;&#123; ... testResultsProcessor:&#39;.&#x2F;testReport&#39;, reporters: [ &#39;default&#39;, [ &#39;.&#x2F;node_modules&#x2F;jest-html-reporter&#39;, &#123; &#x2F;&#x2F;输出页面标题 pageTitle: &#39;Test Report&#39;, &#x2F;&#x2F;插件将会输出的HTML报告的路径。 outputPath:&#39;testReport&#x2F;JesttestReport.html&#39;, &#x2F;&#x2F;为每个失败的测试输出详细的失败消息。 includeFailureMsg: true, &#125;, ], ],&#125; 再次在命令行输入 npm test utils.test.js，我们可以看到测试结果被成功返回在 testReport/JesttestReport.html 中 我们打开生成的 html 文件，测试结果的可视化就完成啦。 总结 掌握单元测试 实现自动生成测试报告 参考阅读 如何将jest的测试结果转移到页面上：https://juejin.im/post/5c2c57ba5188257ed57eb471 关于 jest 测试结果如何在浏览器上显示的问题：https://blog.csdn.net/weixin_34314962/article/details/88811759 Jest官方文档：https://jestjs.io/docs/en/getting-started.html jest-html-reporter官方文档：https://github.com/Hargne/jest-html-reporter/wiki/configuration","categories":[{"name":"函数测试","slug":"函数测试","permalink":"https://shen-yu.gitee.io/categories/%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://shen-yu.gitee.io/tags/nodejs/"},{"name":"Jest","slug":"Jest","permalink":"https://shen-yu.gitee.io/tags/Jest/"}]},{"title":"滚动条样式设置","slug":"CSS/滚动条样式设置","date":"2019-07-07T16:00:00.000Z","updated":"2020-02-07T16:31:46.158Z","comments":true,"path":"2019/ck6gj6ogn0003gkvc8qg017a5/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ogn0003gkvc8qg017a5/","excerpt":"","text":"前言原生的滚动条样式及其丑陋，如果我们不设置滚动条的样式，影响使用心情 滚动条样式设置在 webkit 内核的浏览器中，可以通过以下css属性去修改滚动条样式 1234567891011121314151617181920::-webkit-scrollbar 滚动条整体部分。其中的属性: width,height,background,border等::-webkit-scrollbar-button 滚动条两端的按钮。可以用display:none让其不显示，也可添加背景图片、颜色::-webkit-scrollbar-track 外层轨道。可以用display:none让其不显示，也可以添加背景图片，颜色改变显示效果::-webkit-scrollbar-track-piece 内层轨道。具体区别看下面gif图，需要注意的就是它会覆盖第三个属性的样式::-webkit-scrollbar-thumb 滚动条里面可以拖动的那部分::-webkit-scrollbar-corner 边角，两个滚动条交汇处::-webkit-resizer 两个滚动条交汇处用于拖动调整元素大小的小控件（基本用不上）","categories":[{"name":"前端","slug":"前端","permalink":"https://shen-yu.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"https://shen-yu.gitee.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://shen-yu.gitee.io/tags/CSS/"}]},{"title":"Ubuntu 18.04 安装 MySQL Serve","slug":"Ubuntu/Ubuntu - 安装 MySQL Serve","date":"2019-07-02T16:00:00.000Z","updated":"2020-02-07T16:31:34.486Z","comments":true,"path":"2019/ck6gj6ohe0010gkvcc3nscc5f/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6ohe0010gkvcc3nscc5f/","excerpt":"MySQL是一个免费且广泛使用的开源关系数据库。如果您知道自己需要数据库但对所有可用选项知之甚少，那么这是一个不错的选择。 安装MySQL sudo apt-get updatesudo apt-get install mysql-server 启动MySQL服务安装完成后，您可以通过运行以下命令来启动数据库服务。如果该服务已启动，则会显示一条消息，通知您该服务已在运行： systemctl start mysql 重启时启动要确保在重新引导后启动数据库服务器，请运行以下命令： systemctl enable mysql 跨权使用mysql sudo mysql(用于忘记root密码时配置MySQL)","text":"MySQL是一个免费且广泛使用的开源关系数据库。如果您知道自己需要数据库但对所有可用选项知之甚少，那么这是一个不错的选择。 安装MySQL sudo apt-get updatesudo apt-get install mysql-server 启动MySQL服务安装完成后，您可以通过运行以下命令来启动数据库服务。如果该服务已启动，则会显示一条消息，通知您该服务已在运行： systemctl start mysql 重启时启动要确保在重新引导后启动数据库服务器，请运行以下命令： systemctl enable mysql 跨权使用mysql sudo mysql(用于忘记root密码时配置MySQL) 添加数据库用户当应用程序使用root用户连接到数据库时，它们通常具有超出所需权限的权限。您可以添加应用程序可用于连接到新数据库的用户。 添加新的用户: 这里以user：yang,password:yang 为例 允许本地IP访问localhost的MySQL数据库 mysql;123456789101112131415161718192021show fields from user;select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root |+-----------+------------------+mysql&gt; create user &#39;yang&#39;@&#39;localhost&#39; identified by &#39;yang&#39;;select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| localhost | debian-sys-maint || localhost | mysql.session || localhost | mysql.sys || localhost | root || localhost | yang |+-----------+------------------+ 允许外网IP访问数据库,所有的IP都可以访问该数据库 mysql&gt; create user ‘yang’@’%’ identified by ‘yang’;创建完成后，刷新mysql&gt; flush privileges; 用户授权更改用户赋权，并刷新授权 mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘yang’@’%’ IDENTIFIED BY ‘yang’ WITH GRANT OPTION;mysql&gt; flush privileges; 开启外网访问权限、修改端口开启MySQL远程访问 sudo ufw allow mysql查看3306端口是否对外开放 netstat -an | grep 3306 tcp 0 0 127.0.0.1:3306 0.0.0.0:* LISTEN如果显示如上，说明mysql端口目前只监听本地连接127.0.0.1。然后需要修改mysql的配置文件 cd /etc/mysql/mysql.conf.d sudo vim mysqld.cnf找到bind-address = 127.0.0.1可以修改端口 a 插入模式，注释# Esc ：wq保存退出 重启mysql service mysql restart 可能出现的问题mysql8.0 版本报错: Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决办法（修改加密规则为普通模式，默认是严格加密模式）： mysql -u root -p进入 mysql 后use mysqlALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘password’ PASSWORD EXPIRE NEVER; (修改加密规则)ALTER USER ‘root’@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’; (更新用户密码)FLUSH PRIVILEGES; #刷新权限 数据库操作数据库基本操作 12345678910创建数据库create database dbname charset&#x3D;utf8;删除数据库drop database dbname;切换数据库use dbname;查看当前选择的数据库select database();注. 以上dbname 为数据库名称 表操作 123456789101112131415161718192021查看当前数据库所有表show tables;创建表create table tablename();修改表alter table tablename add|change|drop 列名 类型；删除表drop table tablename;查看表结构desc tablename;查询select * from tablename;增加全列插入: insert into tablename values(....);缺省插入: insert into tablename(列１....) values(值1 .....);同时插入多条数据 insert into tablename values(....),(.....);或 insert into tablename(列１...) values(值１...),(值１....);修改update tablename set 列1&#x3D;值1 ,... where 条件;删除delete from tablename where 条件; 导入sql脚本文件 123进入mysql shellmysql -u root -pEntry password: 首先使用 xftp 传输你的 dbname.sql 文件到 Ubuntu mysql shell 下执行以下命令 12345678创建数据库create database think charset&#x3D;utf8;选择数据库use think;导入sqlsource &#x2F;path&#x2F;path&#x2F;think.sql;注： 以数据库think,SQL脚本think.sql为例 参考阅读阿里开源镜像站：https://opsx.alibaba.com/mirrorUbuntu 下开启 mysql 远程访问：https://www.cnblogs.com/myblog1993/p/10560679.htmlmysql8.0 版本 报错：https://www.jianshu.com/p/c8eb6d2471f8","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shen-yu.gitee.io/categories/Ubuntu/"}],"tags":[{"name":"数据库操作","slug":"数据库操作","permalink":"https://shen-yu.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"},{"name":"MySQL","slug":"MySQL","permalink":"https://shen-yu.gitee.io/tags/MySQL/"},{"name":"xftp","slug":"xftp","permalink":"https://shen-yu.gitee.io/tags/xftp/"}]},{"title":"about","slug":"about/about","date":"2019-06-28T12:10:33.000Z","updated":"2020-02-10T14:23:27.378Z","comments":true,"path":"2019/ck6gj6oif003pgkvcej3v4b1n/","link":"","permalink":"https://shen-yu.gitee.io/2019/ck6gj6oif003pgkvcej3v4b1n/","excerpt":"","text":"关于我一个正在摸爬滚打、努力学习WEB前端的小白程序猿 西南科技大学 2017 级学生 本科专业物联网工程，正在学习前端 大学算是虚度了两年光阴，悔不当初，于是下决心成为一名前端工程师 联系我Email：790041427@qq.com Blog：https://seahaiworld.github.io/blog Gitee：https://gitee.com/SeaHaiWorld Github：https://github.com/SeaHaiWorld 方向：WEB前端，移动端 爱好：吃饭睡觉打游戏 目标：WEB前端工程师","categories":[],"tags":[]}]}